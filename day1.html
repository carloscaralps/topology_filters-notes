
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>1. Filter definition and algebraic structure &#8212; Topology Filters - Notes 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Topology Filters" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="filter-definition-and-algebraic-structure">
<span id="day1"></span><h1><span class="section-number">1. </span>Filter definition and algebraic structure<a class="headerlink" href="#filter-definition-and-algebraic-structure" title="Permalink to this headline">&#182;</a></h1>
<p>We will start defining filters and, then the elementary filter propositions will be proved by the usual way and by Lean.
This chapter aims to define an algebraic structure with filters using two operations.</p>
<section id="filter-definition">
<h2><span class="section-number">1.1. </span>Filter definition<a class="headerlink" href="#filter-definition" title="Permalink to this headline">&#182;</a></h2>
<p>Firstly, we will introduce the filter definition of a giving set.</p>
<p><strong>Definition 1.1</strong> (Filter). <em>Let</em> <code class="docutils literal notranslate"><span class="pre">X</span></code> <em>be a set, a filter is a family of subsets of the power ser</em> <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">&#8838;</span> <span class="pre">&#120031;(X)</span></code> <em>satisfying
the next properties</em></p>
<blockquote>
<div><ol class="lowerroman simple">
<li><p><em>The universal set is in the filter</em> <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>.</p></li>
<li><p><em>If</em> <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>, <em>then</em> <code class="docutils literal notranslate"><span class="pre">&#8704;A</span> <span class="pre">&#8712;</span> <span class="pre">&#120031;(X)</span></code> <em>such that</em> <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">&#8838;</span> <span class="pre">A</span></code>, <em>we have</em> <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>.</p></li>
<li><p><em>If</em> <code class="docutils literal notranslate"><span class="pre">E,A</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>, <em>then</em> <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">&#8745;</span> <span class="pre">A</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>.</p></li>
</ol>
</div></blockquote>
<p>The reader might have noticed we have not included the empty axiom (states that the empty set cannot be in any filter) commonly used in filter definitions and required for topology filter convergence.
Assuming it, would make it impossible to define the neutral element in one of the operations we will use later.</p>
<p>Having the conceptual definition of filters, we can define this structure in Lean. The following code lines were published,
in the mathlib repository, by Johannes H&#246;lzl in August 2018.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=structure%20filter%20(X%20%3A%20Type)%20%3A%3D%0A(sets%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20set%20(set%20X))%0A(univ_sets%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20set.univ%20%E2%88%88%20sets)%0A(sets_of_superset%20%7Bx%20y%7D%20%3A%20x%20%E2%88%88%20sets%20%E2%86%92%20x%20%E2%8A%86%20y%20%E2%86%92%20y%20%E2%88%88%20sets)%0A(inter_sets%20%7Bx%20y%7D%20%20%20%20%20%20%20%3A%20x%20%E2%88%88%20sets%20%E2%86%92%20y%20%E2%88%88%20sets%20%E2%86%92%20x%20%E2%88%A9%20y%20%E2%88%88%20sets)" target="_blank" tryitfile="../examples/day1/unnamed_26.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">structure</span> <span class="n">filter</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sets</span>                   <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">univ_sets</span>              <span class="o">:</span> <span class="n">set.univ</span> <span class="bp">&#8712;</span> <span class="n">sets</span><span class="o">)</span>
<span class="o">(</span><span class="n">sets_of_superset</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">sets</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&#8838;</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">sets</span><span class="o">)</span>
<span class="o">(</span><span class="n">inter_sets</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span>       <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">sets</span> <span class="bp">&#8594;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">sets</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&#8745;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">sets</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Having introduced the definition of filters, we will proceed with defining the principal filters. Those are essential to lots of topological structures as the open neighbourhood of a point.</p>
<p><strong>Definition 1.2</strong> (Principal Filter). <em>Let</em> <code class="docutils literal notranslate"><span class="pre">X</span></code> <em>a set and</em> <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">X</span></code> <em>a subset. We define the principal filter as the subset</em> <code class="docutils literal notranslate"><span class="pre">{t</span> <span class="pre">&#8712;</span> <span class="pre">&#120031;(X)</span> <span class="pre">|</span> <span class="pre">s</span> <span class="pre">&#8838;</span> <span class="pre">t}</span></code>, <em>and from now onwards, it will be denoted as</em> <code class="docutils literal notranslate"><span class="pre">P(A)</span></code>.</p>
<p>We have introduced a definition of what we have supposed to be a particular type of filter. Now, we should prove that it fulfils the conditions for being a filter.</p>
<p><strong>Proposition 1.3</strong> <em>Let</em> <code class="docutils literal notranslate"><span class="pre">X</span></code> <em>a set. For all</em> <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">X</span></code> <em>subsets, the principal filter of</em> <code class="docutils literal notranslate"><span class="pre">A</span></code> <em>is a filter.</em></p>
<p><em>Proof</em>. We will prove that a principal filter is a filter by proving the three properties of filters.</p>
<blockquote>
<div><ol class="lowerroman simple">
<li><p>It is clear that <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">X</span></code>. Then, by definition, we have <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&#8712;</span> <span class="pre">P(A)</span></code>.</p></li>
<li><p>If we have <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">&#8712;</span> <span class="pre">P(A)</span></code>, by definition, we also have <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">E</span></code>. For all <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">&#8712;</span> <span class="pre">&#120031;(X)</span></code> such that <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">&#8838;</span> <span class="pre">B</span></code>, we will have <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">B</span></code> because of fundamental set propositions. Then we can conclude that <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">&#8712;</span> <span class="pre">P(A)</span></code>.</p></li>
<li><p>If we have <code class="docutils literal notranslate"><span class="pre">E,B</span> <span class="pre">&#8712;</span> <span class="pre">P(A)</span></code>, by definition, we will have <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">E</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">B</span></code>. Because <code class="docutils literal notranslate"><span class="pre">A</span></code> is contained in both subsets, we also have <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8838;</span> <span class="pre">E</span> <span class="pre">&#8745;</span> <span class="pre">B</span></code>, which led us to <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">&#8745;</span> <span class="pre">B</span> <span class="pre">&#8712;</span> <span class="pre">P(A)</span></code>. <code class="docutils literal notranslate"><span class="pre">&#8718;</span></code></p></li>
</ol>
</div></blockquote>
<p>When we attend to define a principal filter in Lean, we will be required to prove that this object is a filter. The following lines were published by Johannes H&#246;lzl in August 2018 and define the principal filters in the mathlib repository.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.set.basic%0Aopen%20set%0A%0Astructure%20filter%20(X%20%3A%20Type)%20%3A%3D%0A(sets%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20set%20(set%20X))%0A(univ_sets%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20set.univ%20%E2%88%88%20sets)%0A(sets_of_superset%20%7Bx%20y%7D%20%3A%20x%20%E2%88%88%20sets%20%E2%86%92%20x%20%E2%8A%86%20y%20%E2%86%92%20y%20%E2%88%88%20sets)%0A(inter_sets%20%7Bx%20y%7D%20%20%20%20%20%20%20%3A%20x%20%E2%88%88%20sets%20%E2%86%92%20y%20%E2%88%88%20sets%20%E2%86%92%20x%20%E2%88%A9%20y%20%E2%88%88%20sets)%0A%0Adef%20principal%20%7BX%20%3A%20Type%7D%20(s%20%3A%20set%20X)%20%3A%20filter%20X%20%3A%3D%0A%7B%20sets%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%3D%20%7Bt%20%7C%20s%20%E2%8A%86%20t%7D%2C%0A%20%20univ_sets%20%20%20%20%20%20%20%20%20%3A%3D%20subset_univ%20s%2C%0A%20%20sets_of_superset%20%20%3A%3D%20assume%20x%20y%20hx%20hy%2C%20subset.trans%20hx%20hy%2C%0A%20%20inter_sets%20%20%20%20%20%20%20%20%3A%3D%20assume%20x%20y%2C%20subset_inter%20%7D%0A%0Alocalized%20%22notation%20%60P%60%20%3A%3D%20filter.principal%22%20in%20filter" target="_blank" tryitfile="../examples/day1/unnamed_50.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kd">structure</span> <span class="n">filter</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sets</span>                   <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="n">univ_sets</span>              <span class="o">:</span> <span class="n">set.univ</span> <span class="bp">&#8712;</span> <span class="n">sets</span><span class="o">)</span>
<span class="o">(</span><span class="n">sets_of_superset</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">sets</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&#8838;</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">sets</span><span class="o">)</span>
<span class="o">(</span><span class="n">inter_sets</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span>       <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">sets</span> <span class="bp">&#8594;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">sets</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&#8745;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">sets</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">principal</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sets</span>              <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">&#8838;</span> <span class="n">t</span><span class="o">},</span>
  <span class="n">univ_sets</span>         <span class="o">:=</span> <span class="n">subset_univ</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">sets_of_superset</span>  <span class="o">:=</span> <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="n">subset.trans</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">inter_sets</span>        <span class="o">:=</span> <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">subset_inter</span> <span class="o">}</span>

<span class="n">localized</span> <span class="s2">&quot;notation `P` := filter.principal&quot;</span> <span class="k">in</span> <span class="n">filter</span>
</pre></div>
</div>
</div></section>
<section id="filter-order">
<h2><span class="section-number">1.2. </span>Filter Order<a class="headerlink" href="#filter-order" title="Permalink to this headline">&#182;</a></h2>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Topology Filters - Notes</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Filter definition and algebraic structure</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#filter-definition">1.1. Filter definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filter-order">1.2. Filter Order</a></li>
</ul>
</li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/lean-web-editor/">Lean Live Editor</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/mathlib_docs/">Lean Documentation</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/">Leanprover Community</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Carlos Caralps.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/day1.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>